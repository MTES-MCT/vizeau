import { test } from '@japa/runner'
import testUtils from '@adonisjs/core/services/test_utils'
import { ExploitationService } from '#services/exploitation_service'
import { ExploitationFactory } from '#database/factories/exploitation_factory'
import Exploitation from '#models/exploitation'
import { randomUUID } from 'node:crypto'

test.group('Exploitation service', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction())

  test('I can create an exploitation with a contact', async ({ assert }) => {
    const exploitationPayload = await ExploitationFactory.make()
    const exploitationService = new ExploitationService()

    const persistedExploitation = await exploitationService.createExploitationWithContact(
      exploitationPayload,
      {
        firstName: 'John',
        lastName: 'Doe',
        role: 'parent',
        email: 'john.doe@ld.co',
        phoneNumber: '1234567890',
      }
    )

    await persistedExploitation.load('contacts')

    assert.exists(persistedExploitation.id)
    assert.lengthOf(persistedExploitation.contacts, 1)
    assert.equal(persistedExploitation.contacts[0].firstName, 'John')
  })

  test('I can create an exploitation without a contact', async ({ assert }) => {
    const exploitationPayload = await ExploitationFactory.make()
    const exploitationService = new ExploitationService()

    const persistedExploitation =
      await exploitationService.createExploitationWithContact(exploitationPayload)

    await persistedExploitation.load('contacts')

    assert.exists(persistedExploitation.id)
    assert.lengthOf(persistedExploitation.contacts, 0)
  })

  test("I can't create an exploitation without a name", async ({ assert }) => {
    const exploitationPayload = await ExploitationFactory.make()
    exploitationPayload.name = undefined as any
    const exploitationService = new ExploitationService()

    assert.rejects(() =>
      exploitationService.createExploitationWithContact(exploitationPayload, {
        firstName: 'John',
        lastName: 'Doe',
        role: 'parent',
        email: 'john.doe@ld.co',
        phoneNumber: '1234567890',
      })
    )
  })

  test('I can update an exploitation', async ({ assert }) => {
    const exploitation = await ExploitationFactory.create()
    const exploitationService = new ExploitationService()

    const newName = 'Updated Exploitation Name'

    const updatedExploitation = await exploitationService.updateExploitationWithContact(
      exploitation.id,
      { name: newName }
    )

    assert.equal(updatedExploitation.name, newName)
  })

  test('I can update an exploitation and its contact', async ({ assert }) => {
    const exploitation = await ExploitationFactory.with('contacts', 1).create()
    const exploitationService = new ExploitationService()

    const newName = 'Updated Exploitation Name'
    const newContactName = 'Jane'

    const updatedExploitation = await exploitationService.updateExploitationWithContact(
      exploitation.id,
      { name: newName },
      { firstName: newContactName }
    )

    assert.equal(updatedExploitation.name, newName)
    await updatedExploitation.load('contacts')
    assert.equal(updatedExploitation.contacts[0].firstName, newContactName)
  })

  test("I can create a contact when updating an exploitation that didn't have one", async ({
    assert,
  }) => {
    const exploitation = await ExploitationFactory.create()
    const exploitationService = new ExploitationService()

    const newContactName = 'Jane'
    const updatedExploitation = await exploitationService.updateExploitationWithContact(
      exploitation.id,
      {},
      { firstName: newContactName }
    )
    await updatedExploitation.load('contacts')

    assert.lengthOf(updatedExploitation.contacts, 1)
    assert.equal(updatedExploitation.contacts[0].firstName, newContactName)
  })

  test("I can't update a non-existing exploitation", async ({ assert }) => {
    const exploitationService = new ExploitationService()

    assert.rejects(() =>
      exploitationService.updateExploitationWithContact(randomUUID(), { name: 'Name' })
    )
  })

  test("I can't update an exploitation that has been marked deleted", async ({ assert }) => {
    const exploitation = await ExploitationFactory.merge({ isDeleted: true }).create()
    const exploitationService = new ExploitationService()

    assert.rejects(() =>
      exploitationService.updateExploitationWithContact(exploitation.id, { name: 'Name' })
    )
  })

  test('I can delete an exploitation', async ({ assert }) => {
    const exploitation = await ExploitationFactory.create()
    const exploitationService = new ExploitationService()

    await exploitationService.deleteExploitation(exploitation.id)

    const deletedExploitation = await Exploitation.findOrFail(exploitation.id)
    assert.isTrue(deletedExploitation.isDeleted)
  })

  test('I can search exploitations by name or contact name', async ({ assert }) => {
    const exploitationName = 'Sunny Farm'
    const exploitation = await ExploitationFactory.merge({ name: exploitationName })
      .with('contacts', 1, (contactQuery) => {
        contactQuery.merge({ firstName: 'Alice', lastName: 'Smith' })
      })
      .create()

    const exploitationService = new ExploitationService()

    const emptyQueryResults =
      await exploitationService.searchActiveExploitationsByNameOrContactName('')

    assert.isAtLeast(emptyQueryResults.all().length, 1)
    assert.equal(emptyQueryResults.all()[0].id, exploitation.id)

    const nameQueryResults = await exploitationService.searchActiveExploitationsByNameOrContactName(
      exploitationName.toLowerCase().slice(0, 5)
    )

    assert.isAtLeast(nameQueryResults.all().length, 1)
    assert.equal(nameQueryResults.all()[0].id, exploitation.id)

    // Search by a fragment of the contact name
    const contactQueryResults =
      await exploitationService.searchActiveExploitationsByNameOrContactName('lice Smi')

    assert.isAtLeast(contactQueryResults.all().length, 1)
    assert.equal(contactQueryResults.all()[0].id, exploitation.id)

    const noResults =
      await exploitationService.searchActiveExploitationsByNameOrContactName('NonExistingQuery')

    assert.equal(noResults.all().length, 0)
  })
})
