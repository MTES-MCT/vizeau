import { test } from '@japa/runner'
import testUtils from '@adonisjs/core/services/test_utils'
import { UserFactory } from '#database/factories/user_factory'
import { ExploitationFactory } from '#database/factories/exploitation_factory'
import Parcelle from '#models/parcelle'

const YEAR = 2024
const RPG_ID = 'TEST01'

test.group('Parcelle - Note', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction())

  // ─── getParcelleNote ─────────────────────────────────────────────────────────

  test("Je peux consulter la page de note de parcelle quand je suis propriétaire de l'exploitation", async ({
    client,
    route,
  }) => {
    const user = await UserFactory.create()
    const exploitation = await ExploitationFactory.merge({ userId: user.id }).create()
    await Parcelle.create({ exploitationId: exploitation.id, rpgId: RPG_ID, year: YEAR })

    const response = await client
      .get(route('parcelles.note.get', { exploitationId: exploitation.id, rpgId: RPG_ID }))
      .qs({ year: YEAR })
      .loginAs(user)

    response.assertStatus(200)
  })

  test("Je ne peux pas consulter la page de note d'une exploitation qui ne m'appartient pas", async ({
    client,
    route,
  }) => {
    const user = await UserFactory.create()
    const otherUser = await UserFactory.create()
    const exploitation = await ExploitationFactory.merge({ userId: otherUser.id }).create()
    await Parcelle.create({ exploitationId: exploitation.id, rpgId: RPG_ID, year: YEAR })

    const response = await client
      .get(route('parcelles.note.get', { exploitationId: exploitation.id, rpgId: RPG_ID }))
      .qs({ year: YEAR })
      .loginAs(user)

    response.assertRedirectsTo('/')
  })

  test("Je ne peux pas consulter la page de note d'une parcelle inexistante", async ({
    client,
    route,
  }) => {
    const user = await UserFactory.create()
    const exploitation = await ExploitationFactory.merge({ userId: user.id }).create()

    const response = await client
      .get(route('parcelles.note.get', { exploitationId: exploitation.id, rpgId: 'UNKNOWN' }))
      .qs({ year: YEAR })
      .loginAs(user)

    response.assertRedirectsTo('/')
  })

  // ─── updateParcelleNote ──────────────────────────────────────────────────────

  test('La mise à jour de la note persiste en base de données', async ({
    assert,
    client,
    route,
  }) => {
    const user = await UserFactory.create()
    const exploitation = await ExploitationFactory.merge({ userId: user.id }).create()
    await Parcelle.create({ exploitationId: exploitation.id, rpgId: RPG_ID, year: YEAR })

    const newComment = 'Parcelle bien drainée, à surveiller en juillet.'

    const response = await client
      .patch(route('parcelles.note.update', { exploitationId: exploitation.id, rpgId: RPG_ID }))
      .json({ year: YEAR, comment: newComment })
      .loginAs(user)
      .withCsrfToken()

    response.assertRedirectsTo(
      `/visualisation?exploitationId=${exploitation.id}&parcelleId=${RPG_ID}&millesime=${YEAR}`
    )

    const updatedParcelle = await Parcelle.query()
      .where('rpgId', RPG_ID)
      .andWhere('year', YEAR)
      .andWhere('exploitationId', exploitation.id)
      .first()

    assert.equal(updatedParcelle?.comment, newComment)
  })

  test('Je peux effacer la note en envoyant null', async ({ assert, client, route }) => {
    const user = await UserFactory.create()
    const exploitation = await ExploitationFactory.merge({ userId: user.id }).create()
    await Parcelle.create({
      exploitationId: exploitation.id,
      rpgId: RPG_ID,
      year: YEAR,
      comment: 'Une note existante',
    })

    const response = await client
      .patch(route('parcelles.note.update', { exploitationId: exploitation.id, rpgId: RPG_ID }))
      .json({ year: YEAR, comment: null })
      .loginAs(user)
      .withCsrfToken()

    response.assertRedirectsTo(
      `/visualisation?exploitationId=${exploitation.id}&parcelleId=${RPG_ID}&millesime=${YEAR}`
    )

    const updatedParcelle = await Parcelle.query()
      .where('rpgId', RPG_ID)
      .andWhere('year', YEAR)
      .andWhere('exploitationId', exploitation.id)
      .first()

    assert.isNull(updatedParcelle?.comment)
  })

  test("Je ne peux pas modifier la note d'une exploitation qui ne m'appartient pas", async ({
    assert,
    client,
    route,
  }) => {
    const user = await UserFactory.create()
    const otherUser = await UserFactory.create()
    const exploitation = await ExploitationFactory.merge({ userId: otherUser.id }).create()
    await Parcelle.create({ exploitationId: exploitation.id, rpgId: RPG_ID, year: YEAR })

    const response = await client
      .patch(route('parcelles.note.update', { exploitationId: exploitation.id, rpgId: RPG_ID }))
      .json({ year: YEAR, comment: 'tentative non autorisée' })
      .loginAs(user)
      .withCsrfToken()

    response.assertRedirectsTo('/')

    // Vérification que le commentaire n'a pas été persisté
    const parcelle = await Parcelle.query()
      .where('rpgId', RPG_ID)
      .andWhere('year', YEAR)
      .andWhere('exploitationId', exploitation.id)
      .first()

    assert.isNull(parcelle?.comment)
  })

  test("Je ne peux pas modifier la note d'une parcelle inexistante", async ({ client, route }) => {
    const user = await UserFactory.create()
    const exploitation = await ExploitationFactory.merge({ userId: user.id }).create()

    const response = await client
      .patch(route('parcelles.note.update', { exploitationId: exploitation.id, rpgId: 'UNKNOWN' }))
      .json({ year: YEAR, comment: 'une note' })
      .loginAs(user)
      .withCsrfToken()

    response.assertRedirectsTo('/')
  })
})
