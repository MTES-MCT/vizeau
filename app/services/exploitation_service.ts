import Exploitation from '#models/exploitation'
import Contact from '#models/contact'
import { ModelAttributes } from '@adonisjs/lucid/types/model'

export class ExploitationService {
  /**
   * Query all exploitations that are not marked as deleted.
   */
  queryActiveExploitations() {
    return Exploitation.query().where('isDeleted', false)
  }

  /**
   * Query the latest exploitations created.
   * @param limit Number of exploitations to retrieve. Default is 5.
   */
  queryLatestExploitations(limit = 5) {
    return this.queryActiveExploitations()
      .preload('contacts')
      .orderBy('createdAt', 'desc')
      .limit(limit)
  }

  /**
   * Get the name of an exploitation by its ID.
   * @param exploitationId
   */
  async getExploitationName(exploitationId: string) {
    const exploitation = await Exploitation.findByOrFail({ id: exploitationId, isDeleted: false })

    return exploitation.name
  }

  /**
   * Search active exploitations by their name or by the name of their contacts.
   * @param query
   * @param page
   * @param pageSize
   */
  async searchActiveExploitationsByNameOrContactName(query: string, page = 1, pageSize = 10) {
    const queryBuilder = this.queryActiveExploitations()
      .preload('contacts')
      .orderBy('updatedAt', 'desc')

    if (!query) {
      return queryBuilder.paginate(page, pageSize)
    }

    return queryBuilder
      .where((builder) => {
        builder.where('name', 'ilike', `%${query}%`).orWhereHas('contacts', (contactQuery) => {
          contactQuery.whereRaw(
            "CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, '')) ILIKE ?",
            [`%${query}%`]
          )
        })
      })
      .paginate(page, pageSize)
  }

  async getAllActiveExploitationsByNameOrContactName(query: string) {
    const queryBuilder = this.queryActiveExploitations()
      .preload('contacts')
      .orderBy('updatedAt', 'desc')

    if (query) {
      queryBuilder.where((builder) => {
        builder.where('name', 'ilike', `%${query}%`).orWhereHas('contacts', (contactQuery) => {
          contactQuery.whereRaw(
            "CONCAT(COALESCE(first_name, ''), ' ', COALESCE(last_name, '')) ILIKE ?",
            [`%${query}%`]
          )
        })
      })
    }

    return queryBuilder
  }

  /**
   * Create an exploitation with an optional contact.
   * If contactData is provided and contains a name, a contact will be created and associated with the exploitation.
   */
  async createExploitationWithContact(
    exploitationData: Partial<ModelAttributes<Exploitation>>,
    contactData?: Partial<ModelAttributes<Contact>>
  ) {
    const exploitation = await Exploitation.create(exploitationData)

    if (contactData && Object.values(contactData).some((value) => !!value)) {
      await exploitation.related('contacts').create(contactData)
    }

    return exploitation
  }

  async updateExploitationWithContact(
    exploitationId: string,
    exploitationData: Partial<ModelAttributes<Exploitation>>,
    contactData?: Partial<ModelAttributes<Contact>>
  ) {
    const exploitation = await Exploitation.findByOrFail({ id: exploitationId, isDeleted: false })

    exploitation.merge(exploitationData)
    await exploitation.save()

    if (contactData) {
      const contacts = await exploitation.related('contacts').query()

      if (contacts.length > 0) {
        // We can only have 0 or 1 contact per exploitation for the MVP
        Object.assign(contacts[0], contactData)
        await contacts[0].save()
      } else if (Object.values(contactData).some((value) => !!value)) {
        await exploitation.related('contacts').create(contactData)
      }
    }

    return exploitation
  }

  async deleteExploitation(exploitationId: string) {
    const exploitation = await Exploitation.findOrFail(exploitationId)
    exploitation.isDeleted = true
    await exploitation.save()
  }
}
