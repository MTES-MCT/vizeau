import type { HttpContext } from '@adonisjs/core/http'
import {
  createExploitationValidator,
  updateExploitationValidator,
} from '#validators/create_exploitation'
import { ExploitationService } from '#services/exploitation_service'
import { inject } from '@adonisjs/core'
import { ExploitationDto } from '../dto/exploitation_dto.js'
import router from '@adonisjs/core/services/router'
import { createSuccessFlashMessage, createErrorFlashMessage } from '../helpers/flash_message.js'
import { detachParcelleValidator } from '#validators/parcelle'
import logger from '@adonisjs/core/services/logger'
import { LogEntryTagService } from '#services/log_entry_tag_service'
import { LogEntryTagDto } from '../dto/log_entry_tag_dto.js'
import { LogEntryService } from '#services/log_entry_service'
import { LogEntryDto } from '../dto/log_entry_dto.js'
import { EventLoggerService } from '#services/event_logger_service'
import { ExploitationTagService } from '#services/exploitation_tag_service'
import { ExploitationTagDto } from '../dto/exploitation_tag_dto.js'
import { ParcelleService } from '#services/parcelle_service'

// Définition centralisée des noms d'événements pour ce contrôleur
const EVENTS = {
  INDEX_VIEW: { name: 'exploitations_index', step: 'viewed' },
  CREATE_FORM: { name: 'exploitations_create', step: 'form_viewed' },
  UPDATE_FORM: { name: 'exploitations_update', step: 'form_viewed' },
  PAGE_VIEW: { name: 'exploitation_page_viewed' },
  CREATE_SEARCHED_BY_SIRET: { name: 'exploitations_create', step: 'searched_by_siret' },
  CREATE_SUBMITTED: { name: 'exploitations_create', step: 'submitted' },
  CREATE_CREATED: { name: 'exploitations_create', step: 'created' },
  UPDATE_SUBMITTED: { name: 'exploitations_update', step: 'submitted' },
  UPDATE_UPDATED: { name: 'exploitations_update', step: 'updated' },
  DELETED: { name: 'exploitations_deleted' },
}

@inject()
export default class ExploitationsController {
  constructor(
    public exploitationService: ExploitationService,
    public exploitationTagService: ExploitationTagService,
    public logEntryService: LogEntryService,
    public logEntryTagService: LogEntryTagService,
    public eventLogger: EventLoggerService,
    public parcelleService: ParcelleService
  ) {}

  async index({ request, inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.INDEX_VIEW,
      context: {
        searchQuery: request.input('recherche') || null,
        page: request.input('page', 1),
      },
    })

    return inertia.render('exploitations/index', {
      // Fetches results, paginate and casts to DTOs
      exploitationsWithPagination: async () => {
        const results = await this.exploitationService.searchActiveExploitationsByNameOrContactName(
          request.input('recherche'),
          user.id,
          request.input('page', 1)
        )

        return ExploitationDto.fromPaginator(results)
      },
      // Counts total exploitations
      exploitationCount: async () => {
        const result = await this.exploitationService
          .queryActiveExploitations(user.id)
          .count('*', 'count')
          .first()
        return result ? Number(result.$extras.count) : 0
      },
      // Preserves query string for search input
      queryString: request.qs(),
    })
  }

  async create({ inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_FORM,
    })

    return inertia.render('exploitations/creation', {
      exploitationTags: ExploitationTagDto.fromArray(
        await this.exploitationTagService.getExploitationTags()
      ),
    })
  }

  async getForEdition({ params, inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.UPDATE_FORM,
      context: { exploitationId: params.id },
    })

    const exploitation = await this.exploitationService
      .queryActiveExploitations(user.id)
      .preload('user')
      .preload('contacts')
      .preload('tags')
      .where({ id: params.id })
      .firstOrFail()

    return inertia.render('exploitations/edition', {
      exploitation: ExploitationDto.fromModel(exploitation),
      exploitationTags: ExploitationTagDto.fromArray(
        await this.exploitationTagService.getExploitationTags()
      ),
    })
  }

  // exploitations/id page
  async get({ params, request, inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    const page = request.input('page', 1)

    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.PAGE_VIEW,
      context: { exploitationId: params.id, logPage: page },
    })

    const logEntries = await this.logEntryService.getLogForExploitation(params.id, page, 10)
    const serializedLogEntries = LogEntryDto.fromPaginator(logEntries)

    return inertia.render('exploitations/id', {
      exploitation: async () => {
        const exploitation = await this.exploitationService
          .queryActiveExploitations(user.id)
          .preload('user')
          .preload('contacts')
          .preload('tags')
          .preload('parcelles')
          .where({ id: params.id })
          .firstOrFail()
        return ExploitationDto.fromModel(exploitation)
      },
      /*
        Log entries for this exploitation. We use inertia.merge to append the new data to the existing one.
        This way, when we navigate to the next page, we keep the previous entries in the list.
       */
      logEntries: inertia.merge(() => serializedLogEntries.data),
      logEntriesMeta: serializedLogEntries.meta,
      filteredLogEntryTags: async () => {
        const tags = await this.logEntryTagService.getTagsForExploitation(
          params.id,
          request.qs().tagSearch,
          5
        )

        return LogEntryTagDto.fromArray(tags)
      },
      lastCreatedLogEntryTag: inertia.optional(async () => {
        const tags = await this.logEntryTagService.getTagsForExploitation(params.id, undefined, 1)

        return LogEntryTagDto.fromArray(tags)
      }),
      existingLogEntryTags: inertia.optional(async () => {
        const tags = await this.logEntryTagService.getTagsForLogEntry(request.qs().logEntryId)

        return LogEntryTagDto.fromArray(tags)
      }),
      editExploitationUrl: router.builder().params([params.id]).make('exploitations.edition'),
      deleteExploitationUrl: router.builder().params([params.id]).make('exploitations.destroy'),
      createEntryLogUrl: router.builder().params([params.id]).make('log_entries.create'),
      editEntryLogUrl: router.builder().params([params.id]).make('log_entries.edit'),
      deleteEntryLogUrl: router.builder().params([params.id]).make('log_entries.destroy'),
      createTagForExploitationUrl: router
        .builder()
        .params([params.id])
        .make('log_entries.createTagForExploitation'),
      deleteTagForExploitationUrl: router
        .builder()
        .params([params.id])
        .make('log_entries.destroyTagForExploitation'),
      completeEntryLogUrl: router.builder().params([params.id]).make('log_entries.complete'),
    })
  }

  async getBySiret({ params, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_SEARCHED_BY_SIRET,
      context: { siret: params.siret },
    })

    const exploitation = await this.exploitationService
      .queryActiveExploitations(user.id)
      .where({ siret: params.siret })
      .first()

    return response.json(exploitation)
  }

  async store({ request, session, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_SUBMITTED,
      context: { payload: request.all() },
    })

    const { contacts, tags, ...payload } = await request.validateUsing(createExploitationValidator)

    const exploitation = await this.exploitationService.createExploitationWithContact(
      { ...payload, userId: user.id },
      contacts?.[0]
    )

    if (Array.isArray(tags)) {
      await exploitation.related('tags').sync(tags.map((tag) => tag.id))
    }

    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_CREATED,
    })

    createSuccessFlashMessage(session, `L'exploitation ${payload.name} a été créée.`)

    return response.redirect().toRoute('exploitations.index')
  }

  async edit({ request, session, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.UPDATE_SUBMITTED,
    })

    const { contacts, tags, params, ...payload } = await request.validateUsing(
      updateExploitationValidator
    )

    const exploitation = await this.exploitationService.updateExploitationWithContact(
      params.id,
      payload,
      contacts?.[0]
    )

    if (Array.isArray(tags)) {
      await exploitation.related('tags').sync(tags.map((tag) => tag.id))
    }

    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.UPDATE_UPDATED,
    })

    createSuccessFlashMessage(session, `L'exploitation ${payload.name} a été modifiée.`)

    return response.redirect().toRoute('exploitations.index')
  }

  async destroy({ params, session, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.DELETED,
      context: { exploitationId: params.id },
    })

    await this.exploitationService.deleteExploitation(params.id)

    createSuccessFlashMessage(session, `L'exploitation a été supprimée.`)

    return response.redirect().toRoute('exploitations.index')
  }

  async detachParcelle({ request, response, auth, session }: HttpContext) {
    const user = auth.getUserOrFail()

    try {
      // Validate input
      const { params, year } = await request.validateUsing(detachParcelleValidator)
      const { exploitationId, rpgId } = params

      // Verify that the exploitation belongs to the user
      const exploitation = await this.exploitationService
        .queryActiveExploitations(user.id)
        .where({ id: exploitationId })
        .first()

      if (!exploitation) {
        createErrorFlashMessage(
          session,
          "L'exploitation demandée n'existe pas ou ne vous appartient pas."
        )
        return response.redirect().back()
      }

      await this.parcelleService.detachParcelleFromExploitation(exploitationId, rpgId, year)

      createSuccessFlashMessage(session, 'La parcelle a été détachée avec succès.')
      return response.redirect().back()
    } catch (error) {
      logger.error(error, 'Error detaching parcelle:')
      createErrorFlashMessage(
        session,
        'Une erreur est survenue lors du détachement de la parcelle.'
      )
      return response.redirect().back()
    }
  }
}
