import type { HttpContext } from '@adonisjs/core/http'
import {
  createExploitationValidator,
  updateExploitationValidator,
} from '#validators/create_exploitation'
import { ExploitationService } from '#services/exploitation_service'
import { inject } from '@adonisjs/core'
import { ExploitationDto } from '../dto/exploitation_dto.js'
import router from '@adonisjs/core/services/router'
import { createSuccessFlashMessage } from '../helpers/flash_message.js'
import { LogEntryTagService } from '#services/log_entry_tag_service'
import { LogEntryTagDto } from '../dto/log_entry_tag_dto.js'

@inject()
export default class ExploitationsController {
  constructor(
    public exploitationService: ExploitationService,
    public logEntryTagService: LogEntryTagService
  ) {}

  async index({ request, inertia }: HttpContext) {
    return inertia.render('exploitations/index', {
      // Fetches results, paginate and casts to DTOs
      exploitationsWithPagination: async () => {
        const results = await this.exploitationService.searchActiveExploitationsByNameOrContactName(
          request.input('recherche')
        )

        return new ExploitationDto(results).toJson()
      },
      // Counts total exploitations
      exploitationCount: async () => {
        const result = await this.exploitationService
          .queryActiveExploitations()
          .count('*', 'count')
          .first()
        return result ? Number(result.$extras.count) : 0
      },
      // Preserves query string for search input
      queryString: request.qs(),
    })
  }

  async create({ inertia }: HttpContext) {
    return inertia.render('exploitations/creation')
  }

  async getForEdition({ params, inertia }: HttpContext) {
    const exploitation = await this.exploitationService
      .queryActiveExploitations()
      .preload('contacts')
      .preload('tags')
      .where({ id: params.id })
      .firstOrFail()

    return inertia.render('exploitations/edition', {
      exploitation: ExploitationDto.fromModel(exploitation),
    })
  }

  // exploitations/id page
  async get({ params, request, inertia }: HttpContext) {
    return inertia.render('exploitations/id', {
      exploitation: async () => {
        const exploitation = await this.exploitationService
          .queryActiveExploitations()
          .preload('contacts')
          .preload('tags')
          .preload('logEntries', (logEntryQuery) => {
            logEntryQuery.preload('tags').limit(10).orderBy('createdAt', 'desc')
          })
          .where({ id: params.id })
          .firstOrFail()
        return ExploitationDto.fromModel(exploitation)
      },
      logEntryTags: async () => {
        // Warning: We fetch all the tags for the given exploitation without limit.
        // Maybe find a way to cache the results on the front-end instead?
        const tags = await this.logEntryTagService.getTagsForExploitation(params.id)

        return new LogEntryTagDto(tags).toArray()
      },
      filteredLogEntryTags: async () => {
        const tags = await this.logEntryTagService.getTagsForExploitation(
          params.id,
          request.qs().tagSearch,
          5
        )

        return new LogEntryTagDto(tags).toArray()
      },
      editExploitationUrl: router.builder().params([params.id]).make('exploitations.edition'),
      deleteExploitationUrl: router.builder().params([params.id]).make('exploitations.destroy'),
      createEntryLogUrl: router.builder().params([params.id]).make('log_entries.create'),
      createTagForExploitationUrl: router
        .builder()
        .params([params.id])
        .make('log_entries.createTagForExploitation'),
      deleteTagForExploitationUrl: router
        .builder()
        .params([params.id])
        .make('log_entries.destroyTagForExploitation'),
    })
  }

  async getBySiret({ params, response }: HttpContext) {
    const exploitation = await this.exploitationService
      .queryActiveExploitations()
      .where({ siret: params.siret })
      .first()

    return response.json(exploitation)
  }

  async store({ request, session, response }: HttpContext) {
    const {
      contactFirstName,
      contactLastName,
      contactRole,
      contactEmail,
      contactPhoneNumber,
      latitude,
      longitude,
      ...payload
    } = await request.validateUsing(createExploitationValidator)

    const location =
      latitude !== undefined && latitude !== null && longitude !== undefined && longitude !== null
        ? { x: longitude, y: latitude }
        : undefined

    await this.exploitationService.createExploitationWithContact(
      { ...payload, location },
      {
        firstName: contactFirstName,
        lastName: contactLastName,
        role: contactRole,
        email: contactEmail,
        phoneNumber: contactPhoneNumber,
      }
    )

    createSuccessFlashMessage(session, `L'exploitation ${payload.name} a été créée.`)

    return response.redirect().toRoute('exploitations.index')
  }

  async edit({ request, session, response }: HttpContext) {
    const {
      contactFirstName,
      contactLastName,
      contactRole,
      contactEmail,
      contactPhoneNumber,
      latitude,
      longitude,
      params,
      ...payload
    } = await request.validateUsing(updateExploitationValidator)

    const location =
      latitude !== undefined && latitude !== null && longitude !== undefined && longitude !== null
        ? { x: longitude, y: latitude }
        : undefined

    await this.exploitationService.updateExploitationWithContact(
      params.id,
      { ...payload, location },
      {
        firstName: contactFirstName,
        lastName: contactLastName,
        role: contactRole,
        email: contactEmail,
        phoneNumber: contactPhoneNumber,
      }
    )

    createSuccessFlashMessage(session, `L'exploitation ${payload.name} a été modifiée.`)

    return response.redirect().toRoute('exploitations.index')
  }

  async destroy({ params, session, response }: HttpContext) {
    await this.exploitationService.deleteExploitation(params.id)

    createSuccessFlashMessage(session, `L'exploitation a été supprimée.`)

    return response.redirect().toRoute('exploitations.index')
  }
}
