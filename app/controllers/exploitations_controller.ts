import type { HttpContext } from '@adonisjs/core/http'
import {
  createExploitationValidator,
  updateExploitationValidator,
} from '#validators/create_exploitation'
import { ExploitationService } from '#services/exploitation_service'
import { inject } from '@adonisjs/core'
import { ExploitationDto } from '../dto/exploitation_dto.js'
import router from '@adonisjs/core/services/router'
import { createSuccessFlashMessage } from '../helpers/flash_message.js'
import { LogEntryTagService } from '#services/log_entry_tag_service'
import { LogEntryTagDto } from '../dto/log_entry_tag_dto.js'
import { LogEntryService } from '#services/log_entry_service'
import { LogEntryDto } from '../dto/log_entry_dto.js'
import { EventLoggerService } from '#services/event_logger_service'

// Définition centralisée des noms d'événements pour ce contrôleur
const EVENTS = {
  INDEX_VIEW: { name: 'exploitations_index', step: 'viewed' },
  CREATE_FORM: { name: 'exploitations_create', step: 'form_viewed' },
  UPDATE_FORM: { name: 'exploitations_update', step: 'form_viewed' },
  PAGE_VIEW: { name: 'exploitation_page_viewed' },
  CREATE_SEARCHED_BY_SIRET: { name: 'exploitations_create', step: 'searched_by_siret' },
  CREATE_SUBMITTED: { name: 'exploitations_create', step: 'submitted' },
  CREATE_CREATED: { name: 'exploitations_create', step: 'created' },
  UPDATE_SUBMITTED: { name: 'exploitations_update', step: 'submitted' },
  UPDATE_UPDATED: { name: 'exploitations_update', step: 'updated' },
  DELETED: { name: 'exploitations_deleted' },
}

@inject()
export default class ExploitationsController {
  constructor(
    public exploitationService: ExploitationService,
    public logEntryService: LogEntryService,
    public logEntryTagService: LogEntryTagService,
    public eventLogger: EventLoggerService
  ) {}

  async index({ request, inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.INDEX_VIEW,
      context: {
        searchQuery: request.input('recherche') || null,
        page: request.input('page', 1),
      },
    })

    return inertia.render('exploitations/index', {
      // Fetches results, paginate and casts to DTOs
      exploitationsWithPagination: async () => {
        const results = await this.exploitationService.searchActiveExploitationsByNameOrContactName(
          request.input('recherche'),
          user.id,
          request.input('page', 1)
        )

        return ExploitationDto.fromPaginator(results)
      },
      // Counts total exploitations
      exploitationCount: async () => {
        const result = await this.exploitationService
          .queryActiveExploitations(user.id)
          .count('*', 'count')
          .first()
        return result ? Number(result.$extras.count) : 0
      },
      // Preserves query string for search input
      queryString: request.qs(),
    })
  }

  async create({ inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_FORM,
    })

    return inertia.render('exploitations/creation')
  }

  async getForEdition({ params, inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.UPDATE_FORM,
      context: { exploitationId: params.id },
    })

    const exploitation = await this.exploitationService
      .queryActiveExploitations(user.id)
      .preload('user')
      .preload('contacts')
      .preload('tags')
      .where({ id: params.id })
      .firstOrFail()

    return inertia.render('exploitations/edition', {
      exploitation: ExploitationDto.fromModel(exploitation),
    })
  }

  // exploitations/id page
  async get({ params, request, inertia, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    const page = request.input('page', 1)

    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.PAGE_VIEW,
      context: { exploitationId: params.id, logPage: page },
    })

    const logEntries = await this.logEntryService.getLogForExploitation(params.id, page, 10)
    const serializedLogEntries = LogEntryDto.fromPaginator(logEntries)

    return inertia.render('exploitations/id', {
      exploitation: async () => {
        const exploitation = await this.exploitationService
          .queryActiveExploitations(user.id)
          .preload('user')
          .preload('contacts')
          .preload('tags')
          .where({ id: params.id })
          .firstOrFail()
        return ExploitationDto.fromModel(exploitation)
      },
      /*
        Log entries for this exploitation. We use inertia.merge to append the new data to the existing one.
        This way, when we navigate to the next page, we keep the previous entries in the list.
       */
      logEntries: inertia.merge(() => serializedLogEntries.data),
      logEntriesMeta: serializedLogEntries.meta,
      filteredLogEntryTags: async () => {
        const tags = await this.logEntryTagService.getTagsForExploitation(
          params.id,
          request.qs().tagSearch,
          5
        )

        return LogEntryTagDto.fromArray(tags)
      },
      lastCreatedLogEntryTag: inertia.optional(async () => {
        const tags = await this.logEntryTagService.getTagsForExploitation(params.id, undefined, 1)

        return LogEntryTagDto.fromArray(tags)
      }),
      existingLogEntryTags: inertia.optional(async () => {
        const tags = await this.logEntryTagService.getTagsForLogEntry(request.qs().logEntryId)

        return LogEntryTagDto.fromArray(tags)
      }),
      editExploitationUrl: router.builder().params([params.id]).make('exploitations.edition'),
      deleteExploitationUrl: router.builder().params([params.id]).make('exploitations.destroy'),
      createEntryLogUrl: router.builder().params([params.id]).make('log_entries.create'),
      editEntryLogUrl: router.builder().params([params.id]).make('log_entries.edit'),
      deleteEntryLogUrl: router.builder().params([params.id]).make('log_entries.destroy'),
      createTagForExploitationUrl: router
        .builder()
        .params([params.id])
        .make('log_entries.createTagForExploitation'),
      deleteTagForExploitationUrl: router
        .builder()
        .params([params.id])
        .make('log_entries.destroyTagForExploitation'),
      completeEntryLogUrl: router.builder().params([params.id]).make('log_entries.complete'),
    })
  }

  async getBySiret({ params, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_SEARCHED_BY_SIRET,
      context: { siret: params.siret },
    })

    const exploitation = await this.exploitationService
      .queryActiveExploitations(user.id)
      .where({ siret: params.siret })
      .first()

    return response.json(exploitation)
  }

  async store({ request, session, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_SUBMITTED,
      context: { payload: request.all() },
    })

    const {
      contactFirstName,
      contactLastName,
      contactRole,
      contactEmail,
      contactPhoneNumber,
      latitude,
      longitude,
      ...payload
    } = await request.validateUsing(createExploitationValidator)

    const location =
      latitude !== undefined && latitude !== null && longitude !== undefined && longitude !== null
        ? { x: longitude, y: latitude }
        : undefined

    await this.exploitationService.createExploitationWithContact(
      { ...payload, location, userId: user.id },
      {
        firstName: contactFirstName,
        lastName: contactLastName,
        role: contactRole,
        email: contactEmail,
        phoneNumber: contactPhoneNumber,
      }
    )

    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.CREATE_CREATED,
    })

    createSuccessFlashMessage(session, `L'exploitation ${payload.name} a été créée.`)

    return response.redirect().toRoute('exploitations.index')
  }

  async edit({ request, session, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.UPDATE_SUBMITTED,
    })

    const {
      contactFirstName,
      contactLastName,
      contactRole,
      contactEmail,
      contactPhoneNumber,
      latitude,
      longitude,
      params,
      ...payload
    } = await request.validateUsing(updateExploitationValidator)

    const location =
      latitude !== undefined && latitude !== null && longitude !== undefined && longitude !== null
        ? { x: longitude, y: latitude }
        : undefined

    await this.exploitationService.updateExploitationWithContact(
      params.id,
      { ...payload, location },
      {
        firstName: contactFirstName,
        lastName: contactLastName,
        role: contactRole,
        email: contactEmail,
        phoneNumber: contactPhoneNumber,
      }
    )

    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.UPDATE_UPDATED,
    })

    createSuccessFlashMessage(session, `L'exploitation ${payload.name} a été modifiée.`)

    return response.redirect().toRoute('exploitations.index')
  }

  async destroy({ params, session, response, auth }: HttpContext) {
    const user = auth.getUserOrFail()
    this.eventLogger.logEvent({
      userId: user.id,
      ...EVENTS.DELETED,
      context: { exploitationId: params.id },
    })

    await this.exploitationService.deleteExploitation(params.id)

    createSuccessFlashMessage(session, `L'exploitation a été supprimée.`)

    return response.redirect().toRoute('exploitations.index')
  }
}
