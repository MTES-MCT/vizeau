import { debounce } from 'lodash-es'
import InputWithSelector from '~/ui/InputWithSelector'
import { Button } from '@codegouvfr/react-dsfr/Button'
import { router, usePage } from '@inertiajs/react'
import { InferPageProps } from '@adonisjs/inertia/types'
import ExploitationsController from '#controllers/exploitations_controller'
import { LogEntryTagJson } from '../../../types/models'
import { Tag } from '@codegouvfr/react-dsfr/Tag'

const debouncedFetchTags = debounce((newInput?: string) => {
  router.reload({ only: ['filteredLogEntryTags'], data: { tagSearch: newInput }, replace: true })
}, 300)

type TagSelectorProps = {
  logEntryId?: string
  inputValue: string
  setInputValue: (value: string) => void
  values: number[]
  onChange: (values: number[]) => void
  disabled?: boolean
}

// Every tag fetched is cached for later retrieval
const tagsCache: Record<number, LogEntryTagJson> = {}
// To avoid redundant requests when switching log entries, we track the last requested log entry ID
let lastLogEntryId = ''

export function TagSelector({
  logEntryId,
  inputValue,
  setInputValue,
  values,
  onChange,
  disabled = false,
}: TagSelectorProps) {
  const {
    createTagForExploitationUrl,
    deleteTagForExploitationUrl,
    filteredLogEntryTags,
    existingLogEntryTags,
  } = usePage<InferPageProps<ExploitationsController, 'get'>>().props

  /*
    Cache population
   */
  // We have a log entry ID (edit mode) and it's different from the last one, we request the tags
  if (logEntryId !== undefined && logEntryId !== lastLogEntryId) {
    lastLogEntryId = logEntryId
    router.reload({
      only: ['existingLogEntryTags'],
      data: { logEntryId },
      replace: true,
    })
  }

  // If the requested tags are fetched, we populate the cache
  if (existingLogEntryTags) {
    for (const tag of existingLogEntryTags) {
      tagsCache[tag.id] = tag
    }
  }

  // We also cache the currently filtered tags
  for (const tag of filteredLogEntryTags) {
    tagsCache[tag.id] = tag
  }

  const options = filteredLogEntryTags.map((t) => ({
    value: t.id,
    label: t.name,
    isSelected: values.includes(t.id),
    actions: [
      {
        value: t.id,
        label: "Supprimer l'étiquette",
        iconId: 'fr-icon-delete-bin-line',
        isCritical: true,
        onClick: (value: number) => {
          router.delete(deleteTagForExploitationUrl, {
            data: { tagId: value },
            only: ['exploitation', 'filteredLogEntryTags'],
            replace: true,
            onSuccess: () => {
              // If the deleted tag was selected, we remove it from the selection and from the cache
              if (values.includes(value)) {
                delete tagsCache[value]
                onChange(values.filter((v) => v !== value))
              }
            },
          })
        },
      },
    ],
  }))

  // Retrieve selected tags from cache. Missing tags are undefined while waiting for fetching.
  const selectedTags: Array<LogEntryTagJson | undefined> = values.map((id) => tagsCache[id])

  return (
    <div className="flex flex-col gap-2">
      {!disabled && (
        <div className="flex gap-3 *:first:flex-1">
          <InputWithSelector
            inputValue={inputValue}
            options={options}
            handleInputChange={(newInput) => {
              setInputValue(newInput)
              debouncedFetchTags(newInput)
            }}
            onOptionChange={(updatedOption) => {
              if (updatedOption.isSelected) {
                onChange([...values, updatedOption.value])
              } else {
                onChange(values.filter((v) => v !== updatedOption.value))
              }
            }}
            label="Ajouter des étiquettes"
          />
          <Button
            iconId="fr-icon-add-line"
            nativeButtonProps={{
              type: 'button',
              disabled: disabled || inputValue.trim().length === 0,
              onClick: () => {
                router.post(
                  createTagForExploitationUrl,
                  { name: inputValue },
                  {
                    // After the creation, we reload only the necessary props
                    only: ['filteredLogEntryTags', 'lastCreatedLogEntryTag'],
                    onSuccess: (page) => {
                      // Little type hack to access the Inertia page props
                      const props = page.props as unknown as InferPageProps<
                        ExploitationsController,
                        'get'
                      >

                      setInputValue('')
                      // Add the newly created tag to the selected values
                      if (props.lastCreatedLogEntryTag?.[0]) {
                        onChange([...values, props.lastCreatedLogEntryTag[0].id])
                      }
                    },
                  }
                )
              },
            }}
            className="ml-2 mt-6 self-end"
          >
            Créer
          </Button>
        </div>
      )}
      <div className="flex flex-wrap gap-2">
        {selectedTags.map((tag, i) => {
          if (!tag) {
            // Tag not found in cache, we show a placeholder
            return <Tag key={`missing-${i}`}>...</Tag>
          }
          return (
            <Tag
              key={tag.id}
              nativeButtonProps={{
                disabled,
                onClick: () => {
                  onChange(values.filter((v) => v !== tag.id))
                },
              }}
              dismissible={true}
            >
              {tag.name}
            </Tag>
          )
        })}
      </div>
    </div>
  )
}
