import { debounce } from 'lodash-es'
import InputWithSelector from '~/ui/InputWithSelector'
import { Button } from '@codegouvfr/react-dsfr/Button'
import { router, usePage } from '@inertiajs/react'
import { InferPageProps, SharedProps } from '@adonisjs/inertia/types'
import ExploitationsController from '#controllers/exploitations_controller'
import { LogEntryTagJson } from '../../../types/models'
import { Tag } from '@codegouvfr/react-dsfr/Tag'
import { useRef } from 'react'

const debouncedFetchTags = debounce((newInput?: string) => {
  router.reload({ only: ['filteredLogEntryTags'], data: { tagSearch: newInput }, replace: true })
}, 300)

type TagSelectorProps = {
  logEntryId?: string
  inputValue: string
  setInputValue: (value: string) => void
  values: number[]
  onChange: (values: number[]) => void
  disabled?: boolean
}

// Every tag fetched is cached for later retrieval
const tagsCache: Record<number, LogEntryTagJson> = {}

export function TagSelector({
  logEntryId,
  inputValue,
  setInputValue,
  values,
  onChange,
  disabled = false,
}: TagSelectorProps) {
  const {
    createTagForExploitationUrl,
    deleteTagForExploitationUrl,
    filteredLogEntryTags,
    existingLogEntryTags,
  } = usePage<InferPageProps<ExploitationsController, 'get'>>().props
  const { user } = usePage<SharedProps>().props

  // To avoid redundant requests when switching log entries, we track the last requested log entry ID
  const lastLogEntryId = useRef<string>('')

  /*
    Cache population
   */
  // We have a log entry ID (edit mode) and it's different from the last one, we request the tags
  if (logEntryId !== undefined && logEntryId !== lastLogEntryId.current) {
    lastLogEntryId.current = logEntryId
    router.reload({
      only: ['existingLogEntryTags'],
      data: { logEntryId },
      replace: true,
    })
  }

  // If the requested tags are fetched, we populate the cache
  if (existingLogEntryTags) {
    for (const tag of existingLogEntryTags) {
      tagsCache[tag.id] = tag
    }
  }

  // We also cache the currently filtered tags
  for (const tag of filteredLogEntryTags) {
    tagsCache[tag.id] = tag
  }

  const options = filteredLogEntryTags.map((t) => ({
    value: t.id,
    label: t.name,
    isSelected: values.includes(t.id),
    actions:
      // Only allow deletion of tags created by the current user
      t.userId === user.id
        ? [
            {
              value: t.id,
              label: "Supprimer l'étiquette",
              iconId: 'fr-icon-delete-bin-line',
              isCritical: true,
              onClick: (value: number) => {
                router.delete(deleteTagForExploitationUrl, {
                  data: { tagId: value },
                  only: ['exploitation', 'filteredLogEntryTags'],
                  replace: true,
                  onSuccess: () => {
                    // Remove from cache
                    delete tagsCache[value]
                    // If the deleted tag was selected, we remove it from the selection
                    if (values.includes(value)) {
                      onChange(values.filter((v) => v !== value))
                    }
                  },
                })
              },
            },
          ]
        : undefined,
  }))

  // Retrieve selected tags from cache. Missing tags are undefined while waiting for fetching.
  const selectedTags: Array<LogEntryTagJson | undefined> = values.map((id) => tagsCache[id])

  // Check if the tag name already exists
  const normalizedInput = inputValue ? inputValue.trim().toLowerCase() : ''

  const tagAlreadyExists =
    normalizedInput.length > 0
      ? Object.values(tagsCache).some((tag) => tag.name.trim().toLowerCase() === normalizedInput)
      : false

  return (
    <div className="flex flex-col gap-2">
      {!disabled && (
        <InputWithSelector
          inputValue={inputValue}
          options={options}
          icon="fr-icon-search-line"
          hint="Les étiquettes vous permettent de trier vos tâches plus efficacement."
          handleInputChange={(newInput) => {
            setInputValue(newInput)
            debouncedFetchTags(newInput)
          }}
          onOptionChange={(updatedOption) => {
            if (updatedOption.isSelected) {
              onChange([...values, updatedOption.value])
            } else {
              onChange(values.filter((v) => v !== updatedOption.value))
            }
          }}
          label="Rechercher ou créer une étiquette"
          emptyMenuPlaceholder={
            Object.keys(tagsCache).length === 0 && options.length === 0
              ? "Aucune étiquette n'a encore été créée. Commencez à écrire pour en créer une."
              : 'Cette étiquette n’existe pas encore. Vous pouvez la créer en cliquant sur le bouton de création.'
          }
          additionalActions={
            normalizedInput &&
            !tagAlreadyExists && (
              <Button
                priority="tertiary no outline"
                iconId="fr-icon-add-line"
                type="button"
                style={{ width: '100%' }}
                onClick={() => {
                  router.post(
                    createTagForExploitationUrl,
                    { name: normalizedInput },
                    {
                      // After the creation, we reload only the necessary props
                      only: ['filteredLogEntryTags', 'lastCreatedLogEntryTag'],
                      onSuccess: (page) => {
                        // Little type hack to access the Inertia page props
                        const props = page.props as unknown as InferPageProps<
                          ExploitationsController,
                          'get'
                        >

                        setInputValue('')
                        // Add the newly created tag to the selected values
                        if (props.lastCreatedLogEntryTag?.[0]) {
                          onChange([...values, props.lastCreatedLogEntryTag[0].id])
                        }
                      },
                    }
                  )
                }}
              >
                Créer et ajouter l'étiquette
              </Button>
            )
          }
        />
      )}
      <div className="flex flex-wrap gap-2">
        {selectedTags.length === 0 ? (
          <p>
            <i>Aucune étiquette sélectionnée.</i>
          </p>
        ) : (
          selectedTags.map((tag, i) => {
            if (!tag) {
              // Tag not found in cache, we show a placeholder
              return (
                <Tag key={`missing-${i}`} nativeButtonProps={{ 'aria-label': 'Chargement...' }}>
                  ...
                </Tag>
              )
            }
            return (
              <Tag
                key={tag.id}
                nativeButtonProps={{
                  disabled,
                  onClick: () => {
                    onChange(values.filter((v) => v !== tag.id))
                  },
                }}
                dismissible={true}
              >
                {tag.name}
              </Tag>
            )
          })
        )}
      </div>
    </div>
  )
}
